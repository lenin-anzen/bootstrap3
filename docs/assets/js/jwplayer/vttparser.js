webpackJsonpjwplayer([11], { 47(t, e, n) {
  let r,
    i; r = [n(46)], i = function (t) {
    function e() { return { decode(t) { if (!t) return ''; if (typeof t !== 'string') throw new Error('Error - expected string data.'); return decodeURIComponent(encodeURIComponent(t)); } }; } function n(t) { function e(t, e, n, r) { return 3600 * (0 | t) + 60 * (0 | e) + (0 | n) + (0 | r) / 1e3; } const n = t.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/); return n ? n[3] ? e(n[1], n[2], n[3].replace(':', ''), n[4]) : n[1] > 59 ? e(n[1], n[2], 0, n[4]) : e(0, n[1], n[2], n[4]) : null; } function r() { this.values = Object.create(null); } function i(t, e, n, r) {
      const i = r ? t.split(r) : [t]; for (const a in i) {
        if (typeof i[a] === 'string') {
          const s = i[a].split(n); if (s.length === 2) {
            let o = s[0],
              u = s[1]; e(o, u);
          }
        }
      }
    } function a(t, e, a) {
      function s() { const e = n(t); if (e === null) throw new Error(`Malformed timestamp: ${f}`); return t = t.replace(/^[^\sa-zA-Z-]+/, ''), e; } function c(t, e) {
        const n = new r(); i(t, (t, e) => {
          switch (t) {
            case 'region':for (let r = a.length - 1; r >= 0; r--) if (a[r].id === e) { n.set(t, a[r].region); break; } break; case 'vertical':n.alt(t, e, ['rl', 'lr']); break; case 'line':var i = e.split(','),
              s = i[0]; n.integer(t, s), n.percent(t, s) && n.set('snapToLines', !1), n.alt(t, s, ['auto']), i.length === 2 && n.alt('lineAlign', i[1], ['start', u, 'end']); break; case 'position':i = e.split(','), n.percent(t, i[0]), i.length === 2 && n.alt('positionAlign', i[1], ['start', u, 'end', 'line-left', 'line-right', 'auto']); break; case 'size':n.percent(t, e); break; case 'align':n.alt(t, e, ['start', u, 'end', 'left', 'right']);
          }
        }, /:/, /\s/), e.region = n.get('region', null), e.vertical = n.get('vertical', ''); let s = n.get('line', 'auto'); s === 'auto' && o.line === -1 && (s = -1), e.line = s, e.lineAlign = n.get('lineAlign', 'start'), e.snapToLines = n.get('snapToLines', !0), e.size = n.get('size', 100), e.align = n.get('align', u); let c = n.get('position', 'auto'); c === 'auto' && o.position === 50 && (c = e.align === 'start' || e.align === 'left' ? 0 : e.align === 'end' || e.align === 'right' ? 100 : 50), e.position = c;
      } function l() { t = t.replace(/^\s+/, ''); } var f = t; if (l(), e.startTime = s(), l(), t.substr(0, 3) !== '-->') throw new Error(`Malformed time stamp (time stamps must be separated by '-->'): ${f}`); t = t.substr(3), l(), e.endTime = s(), l(), c(t, e);
    } const s = function (t, n) { this.window = t, this.state = 'INITIAL', this.buffer = '', this.decoder = n || new e(), this.regionList = []; }; r.prototype = { set(t, e) { this.get(t) || e === '' || (this.values[t] = e); }, get(t, e, n) { return n ? this.has(t) ? this.values[t] : e[n] : this.has(t) ? this.values[t] : e; }, has(t) { return t in this.values; }, alt(t, e, n) { for (let r = 0; r < n.length; ++r) if (e === n[r]) { this.set(t, e); break; } }, integer(t, e) { /^-?\d+$/.test(e) && this.set(t, parseInt(e, 10)); }, percent(t, e) { let n; return !!((n = e.match(/^([\d]{1,3})(\.[\d]*)?%$/)) && (e = parseFloat(e), e >= 0 && e <= 100)) && (this.set(t, e), !0); } }; var o = new t(0, 0, 0),
      u = o.align === 'middle' ? 'middle' : 'center'; return s.prototype = { parse(e) { function n() { for (var t = s.buffer, e = 0; e < t.length && t[e] !== '\r' && t[e] !== '\n';)++e; const n = t.substr(0, e); return t[e] === '\r' && ++e, t[e] === '\n' && ++e, s.buffer = t.substr(e), n; } function r(t) { i(t, (t, e) => { switch (t) { case 'Region':console.log('parse region', e); } }, /:/); } var s = this; e && (s.buffer += s.decoder.decode(e, { stream: !0 })); try { let o; if (s.state === 'INITIAL') { if (!/\r\n|\n/.test(s.buffer)) return this; o = n(); const u = o.match(/^WEBVTT([ \t].*)?$/); if (!u || !u[0]) throw new Error('Malformed WebVTT signature.'); s.state = 'HEADER'; } for (let c = !1; s.buffer;) { if (!/\r\n|\n/.test(s.buffer)) return this; switch (c ? c = !1 : o = n(), s.state) { case 'HEADER':/:/.test(o) ? r(o) : o || (s.state = 'ID'); continue; case 'NOTE':o || (s.state = 'ID'); continue; case 'ID':if (/^NOTE($|[ \t])/.test(o)) { s.state = 'NOTE'; break; } if (!o) continue; if (s.cue = new t(0, 0, ''), s.state = 'CUE', o.indexOf('-->') === -1) { s.cue.id = o; continue; } case 'CUE':try { a(o, s.cue, s.regionList); } catch (l) { s.cue = null, s.state = 'BADCUE'; continue; }s.state = 'CUETEXT'; continue; case 'CUETEXT':var f = o.indexOf('-->') !== -1; if (!o || f && (c = !0)) { s.oncue && s.oncue(s.cue), s.cue = null, s.state = 'ID'; continue; }s.cue.text && (s.cue.text += '\n'), s.cue.text += o; continue; case 'BADCUE':o || (s.state = 'ID'); continue; } } } catch (l) { s.state === 'CUETEXT' && s.cue && s.oncue && s.oncue(s.cue), s.cue = null, s.state = s.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE'; } return this; }, flush() { const t = this; try { if (t.buffer += t.decoder.decode(), (t.cue || t.state === 'HEADER') && (t.buffer += '\n\n', t.parse()), t.state === 'INITIAL') throw new Error('Malformed WebVTT signature.'); } catch (e) { throw e; } return t.onflush && t.onflush(), this; } }, s;
  }.apply(e, r), !(void 0 !== i && (t.exports = i));
} });
